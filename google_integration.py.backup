import os
import logging
import time
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple, Any
import pytz

try:
    import gspread
    from google.oauth2.service_account import Credentials
    GSPREAD_AVAILABLE = True
except ImportError:
    GSPREAD_AVAILABLE = False
    gspread = None

from config import Config
from sheets_model import SheetsModelManager

logger = logging.getLogger(__name__)

class GoogleSheetsIntegration:
    """Enhanced Google Sheets integration with QC PANEL → assets sync"""
    
    def __init__(self, config: Config):
        self.config = config
        self.gc = None
        self.spreadsheet = None
        self.assets_worksheet = None
        self.groups_worksheet = None
        self.dashboard_logs_worksheet = None
        self.fleet_status_worksheet = None
        
        # QC Panel integration
        self.qc_panel_spreadsheet = None
        
        # Caching
        self.last_fetch_time = None
        self.cached_driver_names = []
        self.cache_duration = timedelta(minutes=5)
        self._active_cache = {}
        self._active_cache_ts = None
        
        # Logging settings
        self.enable_dashboard_logging = getattr(config, 'ENABLE_DASHBOARD_LOGGING', True)
        
        # Initialize connection
        self._initialize_connection()
        
        # Initialize comprehensive sheets model after connection
        try:
            from sheets_model import SheetsModelManager
            self.sheets_model = SheetsModelManager(self, config)
            logger.info("Comprehensive sheets model initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize sheets model: {e}")
            self.sheets_model = None
    
    def _initialize_connection(self):
        """Initialize Google Sheets connection with enhanced error handling"""
        if not GSPREAD_AVAILABLE:
            raise ImportError("gspread is not installed. Install with: pip install gspread")
        
        try:
            # Use service account file from config
            service_account_file = self.config.SHEETS_SERVICE_ACCOUNT_FILE
            
            if not os.path.exists(service_account_file):
                raise FileNotFoundError(f"Service account file not found: {service_account_file}")
            
            logger.info(f"Using service account file: {service_account_file}")
            
            # Initialize gspread client
            self.gc = gspread.service_account(filename=service_account_file)
            
            # Open the main spreadsheet
            self.spreadsheet = self.gc.open_by_key(self.config.SPREADSHEET_ID)
            logger.info(f"Successfully connected to Google Sheets: {self.config.SPREADSHEET_ID}")
            
            # Initialize QC Panel spreadsheet if configured
            if self.config.QC_PANEL_SPREADSHEET_ID:
                try:
                    self.qc_panel_spreadsheet = self.gc.open_by_key(self.config.QC_PANEL_SPREADSHEET_ID)
                    logger.info(f"Connected to QC Panel spreadsheet: {self.config.QC_PANEL_SPREADSHEET_ID}")
                except Exception as e:
                    logger.warning(f"Could not connect to QC Panel spreadsheet: {e}")
                    self.qc_panel_spreadsheet = None
            
            # Initialize all worksheets
            self._initialize_worksheets()
            
        except Exception as e:
            logger.error(f"Failed to initialize Google Sheets connection: {e}")
            raise
    
    def _initialize_worksheets(self):
        """Initialize all required worksheets"""
        try:
            # Assets worksheet (main data)
            self.assets_worksheet = self.spreadsheet.worksheet(self.config.SPREADSHEET_ASSETS)
            logger.info(f"Connected to assets worksheet: {self.config.SPREADSHEET_ASSETS}")
            
            # Groups worksheet
            try:
                self.groups_worksheet = self.spreadsheet.worksheet(self.config.SPREADSHEET_GROUPS)
                logger.info(f"Connected to groups worksheet: {self.config.SPREADSHEET_GROUPS}")
            except gspread.exceptions.WorksheetNotFound:
                self.groups_worksheet = self._create_groups_worksheet()
                logger.info(f"Created groups worksheet: {self.config.SPREADSHEET_GROUPS}")
            
            # Initialize logging worksheets if enabled
            if self.enable_dashboard_logging:
                self._initialize_dashboard_logs_worksheet()
                self._initialize_fleet_status_worksheet()
            
        except Exception as e:
            logger.error(f"Failed to initialize worksheets: {e}")
            raise
    
    def _create_groups_worksheet(self):
        """Create groups worksheet with proper headers"""
        try:
            worksheet = self.spreadsheet.add_worksheet(
                title=self.config.SPREADSHEET_GROUPS, 
                rows=1000, 
                cols=10
            )
            
            # Set headers
            headers = [
                "group_id", "group_title", "vin", "driver_name", 
                "status", "last_updated", "error_count", "created_at", 
                "updated_at", "notes"
            ]
            worksheet.update('A1', [headers])
            
            logger.info(f"Created groups worksheet with headers: {headers}")
            return worksheet
            
        except Exception as e:
            logger.error(f"Failed to create groups worksheet: {e}")
            raise
    
    def _initialize_dashboard_logs_worksheet(self):
        """Initialize or create dashboard logs worksheet"""
        try:
            worksheet_name = getattr(self.config, 'SPREADSHEET_DASHBOARD', 'dashboard_logs')
            
            try:
                self.dashboard_logs_worksheet = self.spreadsheet.worksheet(worksheet_name)
                logger.info(f"Dashboard logs worksheet '{worksheet_name}' already exists")
            except gspread.exceptions.WorksheetNotFound:
                self.dashboard_logs_worksheet = self.spreadsheet.add_worksheet(
                    title=worksheet_name, rows=2000, cols=12
                )
                
                # Set headers for dashboard logs
                headers = [
                    "timestamp", "event_type", "user_id", "chat_id", "command", 
                    "vin", "driver_name", "success", "error_message", "duration_ms", 
                    "session_data", "notes"
                ]
                self.dashboard_logs_worksheet.update('A1', [headers])
                logger.info(f"Created dashboard logs worksheet '{worksheet_name}'")
                
        except Exception as e:
            logger.error(f"Failed to initialize dashboard logs worksheet: {e}")
    
    def _initialize_fleet_status_worksheet(self):
        """Initialize or create fleet status worksheet"""
        try:
            worksheet_name = getattr(self.config, 'SPREADSHEET_FLEET_STATUS', 'fleet_status')
            
            try:
                self.fleet_status_worksheet = self.spreadsheet.worksheet(worksheet_name)
                logger.info(f"Fleet status worksheet '{worksheet_name}' already exists")
            except gspread.exceptions.WorksheetNotFound:
                self.fleet_status_worksheet = self.spreadsheet.add_worksheet(
                    title=worksheet_name, rows=1000, cols=20
                )
                
                # Set headers for fleet status - match actual worksheet headers
                headers = [
                    "vin", "driver_name", "last_updated", "latitude", "longitude", "address",
                    "speed_mph", "status", "movement_status", "risk_level", "group_chat_id", "last_contact"
                ]
                self.fleet_status_worksheet.update('A1', [headers])
                logger.info(f"Created fleet status worksheet '{worksheet_name}'")
                
        except Exception as e:
            logger.error(f"Failed to initialize fleet status worksheet: {e}")
    
    # =====================================================
    # QC PANEL → ASSETS SYNC IMPLEMENTATION
    # =====================================================
    
    def _open_qc_panel(self):
        """Open QC Panel spreadsheet"""
        if not self.qc_panel_spreadsheet:
            if self.config.QC_PANEL_SPREADSHEET_ID:
                self.qc_panel_spreadsheet = self.gc.open_by_key(self.config.QC_PANEL_SPREADSHEET_ID)
            else:
                raise ValueError("QC_PANEL_SPREADSHEET_ID not configured")
        return self.qc_panel_spreadsheet
    
    @staticmethod
    def _norm(s): 
        """Normalize string value"""
        return str(s or "").strip()
    
    @staticmethod
    def _norm_vin(s): 
        """Normalize VIN value"""
        return str(s or "").strip().upper()
    
    @staticmethod
    def _norm_driver(s): 
        """Normalize driver name"""
        return str(s or "").strip().lower()
    
    def _get_groups_records_safe(self):
        """
        Get groups records safely, bypassing gspread header duplication issues
        """
        try:
            # Try the normal method first
            return self.groups_worksheet.get_all_records()
        except Exception as e:
            if "header row in the worksheet is not unique" in str(e):
                logger.warning("Working around header duplication issue in groups worksheet")
                # Fallback to manual record creation
                try:
                    all_data = self.groups_worksheet.get_all_values()
                    if len(all_data) < 2:
                        return []
                    
                    headers = [h.strip() for h in all_data[0] if h.strip()]  # Remove empty headers
                    data_rows = all_data[1:]
                    
                    records = []
                    for row in data_rows:
                        # Pad row if it's shorter than headers
                        padded_row = row + [''] * (len(headers) - len(row))
                        # Only use non-empty headers
                        record = dict(zip(headers, padded_row[:len(headers)]))
                        records.append(record)
                    
                    logger.info(f"Successfully retrieved {len(records)} records using fallback method")
                    return records
                except Exception as fallback_e:
                    logger.error(f"Fallback method also failed: {fallback_e}")
                    return []
            else:
                logger.error(f"Error getting groups records: {e}")
                return []
    
    def col_to_a1(self, n: int) -> str:
        """Convert column number to A1 notation"""
        s = ""
        while n:
            n, r = divmod(n - 1, 26)
            s = chr(65 + r) + s
        return s
    
    def get_active_load_map(self) -> dict:
        """
        Build dict of active loads keyed by VIN and by driver (fallback).
        Include only rows where STS OF DEL (col S) is one of the monitored statuses.
        Exact QC PANEL columns:
          D '#' (Load id), T 'PU APT', U 'PU ADDRESS', V 'DEL APT', W 'DEL ADDRESS'
          R 'STS OF PU', S 'STS OF DEL'
        """
        if not self.config.QC_PANEL_SPREADSHEET_ID:
            logger.warning("QC Panel spreadsheet not configured")
            return {}
        
        try:
            sh = self._open_qc_panel()
            tabs = [t.strip() for t in (self.config.QC_ACTIVE_TABS or "").split(",") if t.strip()]
            watch = {x.strip().upper() for x in (self.config.RISK_MONITOR_DEL_STATUSES or "").split(",")}
            out = {}

            for tab in tabs:
                try:
                    ws = sh.worksheet(tab)
                    # Use safe method for QC Panel worksheets
                    try:
                        rows = ws.get_all_records()  # assumes header row 1
                    except Exception as e:
                        if "header row in the worksheet is not unique" in str(e):
                            logger.warning(f"Working around header duplication issue in QC Panel tab '{tab}'")
                            try:
                                all_data = ws.get_all_values()
                                if len(all_data) < 2:
                                    continue
                                headers = [h.strip() for h in all_data[0] if h.strip()]
                                data_rows = all_data[1:]
                                rows = []
                                for row in data_rows:
                                    padded_row = row + [''] * (len(headers) - len(row))
                                    record = dict(zip(headers, padded_row[:len(headers)]))
                                    rows.append(record)
                                logger.info(f"Successfully retrieved {len(rows)} QC Panel records using fallback method for tab '{tab}'")
                            except Exception as fallback_e:
                                logger.error(f"Fallback method failed for QC Panel tab '{tab}': {fallback_e}")
                                continue
                        else:
                            logger.error(f"Error getting QC Panel records from tab '{tab}': {e}")
                            continue

                    for r in rows:
                        vin     = self._norm_vin(r.get("VIN", ""))
                        driver  = self._norm_driver(r.get("DRIVER", ""))
                        del_sts = self._norm(r.get("STS OF DEL", "")).upper()
                        
                        if del_sts not in watch:
                            continue

                        payload = {
                            "driver_name": self._norm(r.get("DRIVER", "")),
                            "load_id":     self._norm(r.get("#", "")),                 # D
                            "pu_address":  self._norm(r.get("PU ADDRESS", "")),        # U
                            "pu_appt":     self._norm(r.get("PU APT", "")),            # T
                            "del_address": self._norm(r.get("DEL ADDRESS", "")),       # W
                            "del_appt":    self._norm(r.get("DEL APT", "")),           # V
                            "pu_status":   self._norm(r.get("STS OF PU", "")),         # R
                            "del_status":  del_sts,                                     # S
                            "in_transit":  True,
                            "is_late":     del_sts == "WILL BE LATE",
                        }
                        if vin:    out[vin]    = payload
                        if driver: out[driver] = payload
                except Exception as e:
                    logger.error(f"Error processing QC Panel tab '{tab}': {e}")
                    continue
            
            logger.debug(f"Found {len(out)} active loads from QC Panel")
            return out
        except Exception as e:
            logger.error(f"Error getting active load map: {e}")
            return {}

    def get_active_load_status_for_vin(self, vin: str) -> dict | None:
        """Get active load status for specific VIN with caching"""
        now = datetime.utcnow()
        cache_ts = getattr(self, "_active_cache_ts", None)
        if not cache_ts or (now - cache_ts).seconds > 90:
            self._active_cache = self.get_active_load_map()
            self._active_cache_ts = now
        return self._active_cache.get(self._norm_vin(vin))

    def sync_active_loads_to_assets(self) -> int:
        """
        Write Load id + PU/DEL fields into assets (columns O:S) when matched by VIN/Driver.
        Target headers in assets: 'Load id','PU address','PU appt','DEL address','DEL appt'
        """
        if not self.config.QC_PANEL_SPREADSHEET_ID:
            logger.debug("QC Panel not configured, skipping sync")
            return 0
        
        try:
            active = self.get_active_load_map()
            if not active:
                logger.debug("No active loads found, skipping sync")
                return 0

            ws = self.assets_worksheet
            data = self._get_assets_records_safe()
            headers = ws.row_values(1)

            def col(name): 
                return headers.index(name) + 1 if name in headers else None

            c = {
                "VIN": col("VIN"),
                "Driver": col("Driver Name"),
                "Load": col("Load id"),
                "PU_ADDR": col("PU address"),
                "PU_APPT": col("PU appt"),
                "DEL_ADDR": col("DEL address"),
                "DEL_APPT": col("DEL appt"),
            }
            
            # Check if required columns exist
            missing_cols = [name for name, col_idx in c.items() if col_idx is None]
            if missing_cols:
                logger.warning(f"Missing columns in assets sheet: {missing_cols}")
                # Add missing columns if needed
                self._ensure_assets_columns(headers, missing_cols)
                # Refresh headers and column mapping
                headers = ws.row_values(1)
                c = {
                    "VIN": col("VIN"),
                    "Driver": col("Driver Name"),
                    "Load": col("Load id"),
                    "PU_ADDR": col("PU address"),
                    "PU_APPT": col("PU appt"),
                    "DEL_ADDR": col("DEL address"),
                    "DEL_APPT": col("DEL appt"),
                }
            
            updates = []
            for i, rec in enumerate(data, start=2):
                vin = self._norm_vin(rec.get("VIN", ""))
                drv = self._norm_driver(rec.get("Driver Name", ""))

                src = active.get(vin) or active.get(drv)
                if not src:
                    continue

                def rng(ci): 
                    return f"{self.col_to_a1(ci)}{i}"

                if c["Load"]:     updates.append({"range": rng(c["Load"]),     "values": [[src["load_id"]]]})
                if c["PU_ADDR"]:  updates.append({"range": rng(c["PU_ADDR"]),  "values": [[src["pu_address"]]]})
                if c["PU_APPT"]:  updates.append({"range": rng(c["PU_APPT"]),  "values": [[src["pu_appt"]]]})
                if c["DEL_ADDR"]: updates.append({"range": rng(c["DEL_ADDR"]), "values": [[src["del_address"]]]})
                if c["DEL_APPT"]: updates.append({"range": rng(c["DEL_APPT"]), "values": [[src["del_appt"]]]})

            if updates:
                ws.batch_update(updates)
                logger.info(f"Synced {len(updates)} load data updates to assets sheet")
            
            return len(updates)
        except Exception as e:
            logger.error(f"Error syncing active loads to assets: {e}")
            return 0
    
    def _ensure_assets_columns(self, current_headers: List[str], missing_cols: List[str]):
        """Ensure required columns exist in assets worksheet"""
        try:
            col_mapping = {
                "Load": "Load id",
                "PU_ADDR": "PU address", 
                "PU_APPT": "PU appt",
                "DEL_ADDR": "DEL address",
                "DEL_APPT": "DEL appt"
            }
            
            new_headers = current_headers.copy()
            for col_key in missing_cols:
                if col_key in col_mapping:
                    new_headers.append(col_mapping[col_key])
            
            # Update header row
            self.assets_worksheet.update('1:1', [new_headers])
            logger.info(f"Added missing columns to assets sheet: {[col_mapping.get(c, c) for c in missing_cols]}")
        except Exception as e:
            logger.error(f"Error adding columns to assets sheet: {e}")
    
    # Routing helper (VIN -> destination chats)
    def resolve_destinations(self, vin: str) -> list[int]:
        """
        Returns [qc_group_chat_id(s) from groups sheet for VIN] + [management].
        """
        try:
            chat_ids = list(self.lookup_group_ids_by_vin(vin) or [])
            mgmt = getattr(self.config, "MGMT_CHAT_ID", None)
            if mgmt:
                # Handle both single ID and comma-separated list
                if isinstance(mgmt, str) and ',' in mgmt:
                    mgmt_ids = [int(x.strip()) for x in mgmt.split(',') if x.strip()]
                    chat_ids.extend(mgmt_ids)
                elif mgmt:
                    try:
                        chat_ids.append(int(mgmt))
                    except ValueError:
                        logger.warning(f"Invalid MGMT_CHAT_ID format: {mgmt}")
            
            # Add QC team chat if configured
            if self.config.QC_TEAM_CHAT_ID:
                chat_ids.append(self.config.QC_TEAM_CHAT_ID)
            
            # De-duplicate
            return list(dict.fromkeys(chat_ids))
        except Exception as e:
            logger.error(f"Error resolving destinations for VIN {vin}: {e}")
            return []
    
    def lookup_group_ids_by_vin(self, vin: str) -> List[int]:
        """Look up group chat IDs associated with a VIN"""
        try:
            if not self.groups_worksheet:
                return []
            
            records = self._get_groups_records_safe()
            group_ids = []
            
            for record in records:
                if (record.get('vin', '').upper().strip() == vin.upper().strip() and 
                    record.get('status', '').upper() == 'ACTIVE'):
                    group_id = record.get('group_id')
                    if group_id:
                        try:
                            group_ids.append(int(group_id))
                        except ValueError:
                            continue
            
            return group_ids
        except Exception as e:
            logger.error(f"Error looking up group IDs for VIN {vin}: {e}")
            return []
    
    # =====================================================
    # EXISTING METHODS (unchanged)
    # =====================================================
    
    def get_all_driver_names(self) -> List[str]:
        """Get all driver names from assets worksheet - FIXED to read from column D"""
        try:
            # Use cache if available and fresh
            if (self.last_fetch_time and 
                datetime.now() - self.last_fetch_time < self.cache_duration and 
                self.cached_driver_names):
                logger.debug("Using cached driver names")
                return self.cached_driver_names
            
            # Get all records from assets worksheet - use safe method
            records = self._get_assets_records_safe()
            
            driver_names = []
            seen_names = set()
            
            for record in records:
                # Column D contains "Driver Name" - get it directly
                driver_name = str(record.get('Driver Name', '')).strip()
                
                # Skip empty or obviously invalid names
                if (driver_name and 
                    driver_name not in seen_names and 
                    driver_name.lower() != 'driver name' and  # Skip header
                    len(driver_name) > 2 and  # Skip too short names
                    not driver_name.startswith('#')):  # Skip error values
                    
                    driver_names.append(driver_name)
                    seen_names.add(driver_name)
            
            # Update cache
            self.cached_driver_names = driver_names
            self.last_fetch_time = datetime.now()
            
            logger.info(f"Loaded {len(driver_names)} driver names from assets worksheet")
            return driver_names
            
        except Exception as e:
            logger.error(f"Error getting driver names: {e}")
            return []
    
    def find_vin_by_driver_name(self, driver_name: str) -> Optional[str]:
        """Find VIN by driver name using fuzzy matching - FIXED to use Driver Name column"""
        try:
            # Get all records from assets worksheet - use safe method
            records = self._get_assets_records_safe()
            
            driver_name_lower = driver_name.lower().strip()
            
            # First try exact match on Driver Name column
            for record in records:
                # Column D is "Driver Name" in your sheet
                sheet_driver_name = str(record.get('Driver Name', '')).lower().strip()
                
                if sheet_driver_name and sheet_driver_name == driver_name_lower:
                    vin = str(record.get('VIN', '')).strip()
                    if vin:
                        logger.info(f"Exact match found: '{driver_name}' -> VIN: {vin}")
                        return vin.upper()
            
            # If no exact match, try partial matching
            best_match = None
            best_score = 0
            
            for record in records:
                # Get driver name from Driver Name column
                sheet_driver_name = str(record.get('Driver Name', '')).lower().strip()
                
                if not sheet_driver_name:
                    continue
                    
                vin = str(record.get('VIN', '')).strip()
                if not vin:
                    continue
                
                # Calculate similarity score
                score = 0
                
                # Check if search name is contained in sheet name or vice versa
                if driver_name_lower in sheet_driver_name or sheet_driver_name in driver_name_lower:
                    score = 0.8
                
                # Check word matches
                search_words = set(driver_name_lower.split())
                sheet_words = set(sheet_driver_name.split())
                
                if search_words and sheet_words:
                    common_words = search_words.intersection(sheet_words)
                    word_score = len(common_words) / max(len(search_words), len(sheet_words))
                    score = max(score, word_score)
                
                # Check if first name or last name matches
                if len(search_words) >= 1 and len(sheet_words) >= 1:
                    if (search_words & sheet_words):  # Any word matches
                        score = max(score, 0.6)
                
                if score > best_score and score >= 0.6:  # Minimum 60% confidence
                    best_score = score
                    best_match = (vin.upper(), sheet_driver_name, score)
            
            if best_match:
                vin, matched_name, score = best_match
                logger.info(f"Fuzzy match found: '{driver_name}' -> '{matched_name}' (score: {score:.2f}) -> VIN: {vin}")
                return vin
            
            logger.warning(f"No match found for driver name: '{driver_name}'")
            return None
            
        except Exception as e:
            logger.error(f"Error finding VIN by driver name '{driver_name}': {e}")
            return None
    
    def find_similar_driver_names(self, search_name: str) -> List[str]:
        """Find similar driver names for suggestions - FIXED to use Driver Name column"""
        try:
            records = self._get_assets_records_safe()
            search_lower = search_name.lower().strip()
            
            suggestions = []
            seen_names = set()
            
            for record in records:
                # Get driver name from Driver Name column
                driver_name = str(record.get('Driver Name', '')).strip()
                
                if not driver_name or driver_name.lower() in seen_names:
                    continue
                    
                # Skip header row or invalid names
                if driver_name.lower() == 'driver name' or len(driver_name) < 2:
                    continue
                    
                seen_names.add(driver_name.lower())
                driver_lower = driver_name.lower()
                
                # Add to suggestions if it's a partial match
                if (search_lower in driver_lower or 
                    driver_lower in search_lower or 
                    any(word in driver_lower for word in search_lower.split()) or
                    any(word in search_lower for word in driver_lower.split())):
                    suggestions.append(driver_name)
            
            # Sort by relevance (exact substring matches first)
            def relevance_score(name):
                name_lower = name.lower()
                if search_lower in name_lower:
                    return 0  # Highest priority
                elif name_lower in search_lower:
                    return 1
                else:
                    return 2  # Word matches
            
            suggestions.sort(key=relevance_score)
            
            logger.info(f"Found {len(suggestions)} similar names for '{search_name}': {suggestions[:5]}")
            return suggestions[:10]  # Return top 10 matches
            
        except Exception as e:
            logger.error(f"Error finding similar driver names for '{search_name}': {e}")
            return []
    
    def get_driver_contact_info_by_vin(self, vin: str) -> Tuple[Optional[str], Optional[str]]:
        """Get driver name and phone by VIN - FIXED to return proper driver name from Driver Name column"""
        try:
            records = self._get_assets_records_safe()
            vin_upper = vin.upper().strip()
            
            for record in records:
                record_vin = str(record.get('VIN', '')).upper().strip()
                if record_vin == vin_upper:
                    # Get driver name from Driver Name column
                    driver_name = str(record.get('Driver Name', '')).strip()
                    
                    # Handle multiple driver names (data quality fix)
                    if driver_name and ' / ' in driver_name:
                        # Take the first driver name when multiple names are present
                        driver_name = driver_name.split(' / ')[0].strip()
                        logger.debug(f"Multiple drivers found for VIN {vin}, using first: '{driver_name}'")
                    
                    # Get phone number from Phone column
                    phone = str(record.get('Phone', '')).strip()
                    
                    logger.debug(f"Contact info for VIN {vin}: Driver: '{driver_name}', Phone: '{phone}'")
                    return driver_name if driver_name else None, phone if phone else None
            
            logger.debug(f"No contact info found for VIN: {vin}")
            return None, None
            
        except Exception as e:
            logger.error(f"Error getting contact info for VIN {vin}: {e}")
            return None, None
    
    def get_driver_name_by_vin(self, vin: str) -> Optional[str]:
        """Get driver name by VIN - FIXED to return proper driver name from Driver Name column"""
        try:
            records = self._get_assets_records_safe()
            vin_upper = vin.upper().strip()
            
            for record in records:
                record_vin = str(record.get('VIN', '')).upper().strip()
                if record_vin == vin_upper:
                    # Get driver name from Driver Name column
                    driver_name = str(record.get('Driver Name', '')).strip()
                    
                    # Handle multiple driver names (data quality fix)
                    if driver_name and ' / ' in driver_name:
                        # Take the first driver name when multiple names are present
                        driver_name = driver_name.split(' / ')[0].strip()
                        logger.debug(f"Multiple drivers found for VIN {vin}, using first: '{driver_name}'")
                    
                    if driver_name:
                        logger.debug(f"Driver name for VIN {vin}: '{driver_name}'")
                        return driver_name
            
            logger.debug(f"No driver name found for VIN: {vin}")
            return None
            
        except Exception as e:
            logger.error(f"Error getting driver name for VIN {vin}: {e}")
            return None
    
    def get_driver_contact_info(self, driver_name: str) -> Tuple[Optional[str], Optional[str]]:
        """Get driver contact info by name - FIXED to search in Driver Name column"""
        try:
            records = self._get_assets_records_safe()
            driver_name_lower = driver_name.lower().strip()
            
            for record in records:
                # Search in Driver Name column
                sheet_driver_name = str(record.get('Driver Name', '')).lower().strip()
                
                if sheet_driver_name == driver_name_lower:
                    # Return the actual driver name (with proper casing) and phone
                    actual_name = str(record.get('Driver Name', '')).strip()
                    phone = str(record.get('Phone', '')).strip()
                    
                    logger.info(f"Contact info for driver '{driver_name}': Phone: '{phone}'")
                    return actual_name, phone if phone else None
            
            logger.warning(f"No contact info found for driver: {driver_name}")
            return None, None
            
        except Exception as e:
            logger.error(f"Error getting contact info for driver '{driver_name}': {e}")
            return None, None
    
    # Group management functions
    def get_group_vin(self, group_id: int) -> Optional[str]:
        """Get VIN for a group from groups worksheet"""
        try:
            if not self.groups_worksheet:
                logger.error("Groups worksheet not initialized")
                return None
            
            records = self._get_groups_records_safe()
            
            for record in records:
                if int(record.get('group_id', 0)) == group_id:
                    vin = str(record.get('vin', '')).strip()
                    if vin:
                        logger.info(f"Found VIN for group {group_id}: {vin}")
                        return vin.upper()
            
            logger.info(f"No VIN found for group {group_id}")
            return None
            
        except Exception as e:
            logger.error(f"Error getting group VIN for {group_id}: {e}")
            return None
    
    def save_group_vin(self, group_id: int, group_title: str, vin: str, driver_name: Optional[str] = None) -> bool:
        """Save VIN for a group to groups worksheet"""
        try:
            if not self.groups_worksheet:
                logger.error("Groups worksheet not initialized")
                return False
            
            # Check if group already exists
            records = self._get_groups_records_safe()
            existing_row = None
            
            for i, record in enumerate(records):
                if int(record.get('group_id', 0)) == group_id:
                    existing_row = i + 2  # +2 because sheets are 1-indexed and we skip header
                    break
            
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Get driver name if not provided
            if not driver_name and vin:
                driver_name = self.get_driver_name_by_vin(vin)
            
            # Row data matching the actual headers: ['group_id', 'group_title', 'vin', 'status', 'last_updated', 'error_count']
            row_data = [
                group_id,
                group_title,
                vin.upper(),
                'ACTIVE',  # status
                current_time,  # last_updated
                0,  # error_count
            ]
            
            if existing_row:
                # Update existing row
                self.groups_worksheet.update(f'A{existing_row}', [row_data])
                logger.info(f"Updated group {group_id} with VIN {vin}")
            else:
                # Add new row
                self.groups_worksheet.append_row(row_data)
                logger.info(f"Added new group {group_id} with VIN {vin}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error saving group VIN for {group_id}: {e}")
            return False
    
    # Enhanced logging functions
    
    def log_dashboard_event(self, event_type: str, user_id: int, chat_id: int, 
                           command: str, vin: Optional[str] = None, 
                           driver_name: Optional[str] = None, success: bool = True,
                           error_message: Optional[str] = None, duration_ms: int = 0,
                           session_data: Optional[str] = None) -> bool:
        """Log dashboard events to dashboard logs worksheet for user analytics"""
        if not self.enable_dashboard_logging or not self.dashboard_logs_worksheet:
            return False
        
        try:
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            row_data = [
                current_time,
                event_type,
                user_id,
                chat_id,
                command,
                vin or '',
                driver_name or '',
                'SUCCESS' if success else 'FAILED',
                error_message or '',
                duration_ms,
                session_data or '',  # session_data for context
                f'Event logged at {current_time}'
            ]
            
            self.dashboard_logs_worksheet.append_row(row_data)
            logger.debug(f"Logged dashboard event: {event_type} - {command} for user {user_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error logging dashboard event: {e}")
            return False
    
    def log_command_execution(self, user_id: int, chat_id: int, command: str, 
                             success: bool = True, error_message: Optional[str] = None,
                             vin: Optional[str] = None, driver_name: Optional[str] = None,
                             duration_ms: int = 0, extra_info: Optional[str] = None) -> bool:
        """Convenience method for logging command executions"""
        return self.log_dashboard_event(
            event_type="COMMAND_EXECUTION",
            user_id=user_id,
            chat_id=chat_id,
            command=command,
            vin=vin,
            driver_name=driver_name,
            success=success,
            error_message=error_message,
            duration_ms=duration_ms,
            session_data=extra_info
        )
    
    def log_user_interaction(self, user_id: int, chat_id: int, interaction_type: str,
                            details: Optional[str] = None, success: bool = True) -> bool:
        """Log user interactions like button clicks, menu selections, etc."""
        return self.log_dashboard_event(
            event_type="USER_INTERACTION",
            user_id=user_id,
            chat_id=chat_id,
            command=interaction_type,
            success=success,
            session_data=details
        )
    
    def _get_fleet_status_records_safe(self):
        """
        Get fleet status records safely, bypassing gspread header duplication issues
        """
        try:
            # Try the normal method first
            return self.fleet_status_worksheet.get_all_records()
        except Exception as e:
            if "header row in the worksheet is not unique" in str(e):
                logger.warning("Working around header duplication issue in fleet status worksheet")
                # Fallback to manual record creation
                try:
                    all_data = self.fleet_status_worksheet.get_all_values()
                    if len(all_data) < 2:
                        return []
                    
                    headers = [h.strip() for h in all_data[0] if h.strip()]  # Remove empty headers
                    data_rows = all_data[1:]
                    
                    records = []
                    for row in data_rows:
                        # Pad row if it's shorter than headers
                        padded_row = row + [''] * (len(headers) - len(row))
                        # Only use non-empty headers
                        record = dict(zip(headers, padded_row[:len(headers)]))
                        records.append(record)
                    
                    logger.info(f"Successfully retrieved {len(records)} fleet status records using fallback method")
                    return records
                except Exception as fallback_e:
                    logger.error(f"Fallback method also failed: {fallback_e}")
                    return []
            else:
                logger.error(f"Error getting fleet status records: {e}")
                return []

    def _get_assets_records_safe(self):
        """
        Get assets records safely, bypassing gspread header duplication issues
        """
        try:
            # Try the normal method first
            return self.assets_worksheet.get_all_records()
        except Exception as e:
            if "header row in the worksheet is not unique" in str(e):
                logger.warning("Working around header duplication issue in assets worksheet")
                # Fallback to manual record creation
                try:
                    all_data = self.assets_worksheet.get_all_values()
                    if len(all_data) < 2:
                        return []
                    
                    headers = [h.strip() for h in all_data[0] if h.strip()]  # Remove empty headers
                    data_rows = all_data[1:]
                    
                    records = []
                    for row in data_rows:
                        # Pad row if it's shorter than headers
                        padded_row = row + [''] * (len(headers) - len(row))
                        # Only use non-empty headers
                        record = dict(zip(headers, padded_row[:len(headers)]))
                        records.append(record)
                    
                    logger.info(f"Successfully retrieved {len(records)} assets records using fallback method")
                    return records
                except Exception as fallback_e:
                    logger.error(f"Fallback method also failed: {fallback_e}")
                    return []
            else:
                logger.error(f"Error getting assets records: {e}")
                return []

    def update_fleet_status_sheet(self, trucks: List[Dict[str, Any]]) -> bool:
        """Update fleet_status worksheet with current truck location data from TMS"""
        # Use the fixed method that updates fleet_status worksheet
        try:
            return self.update_fleet_status_sheet_fixed(trucks)
        except Exception as e:
            logger.error(f"Error in fleet_status update: {e}")
            return False
    
    def update_asset_tracking_sheet(self, trucks: List[Dict[str, Any]]) -> bool:
        """DEPRECATED: Use update_fleet_status_sheet instead - this was updating fleet_status worksheet"""
        logger.warning("update_asset_tracking_sheet is deprecated, use update_fleet_status_sheet instead")
        return self.update_fleet_status_sheet(trucks)
    
    def cleanup_fleet_status_duplicates(self, dry_run: bool = True) -> Dict[str, Any]:
        """
        Clean up duplicate entries in fleet_status worksheet (EMERGENCY CLEANUP)
        
        Args:
            dry_run: If True, only analyze without making changes
            
        Returns:
            Dictionary with cleanup statistics
        """
        if not self.fleet_status_worksheet:
            return {"error": "Fleet status worksheet not available"}
        
        try:
            logger.info("Starting fleet status cleanup analysis...")
            
            # Get all data
            all_data = self.fleet_status_worksheet.get_all_values()
            if len(all_data) < 2:
                return {"error": "No data to clean"}
            
            headers = all_data[0]
            data_rows = all_data[1:]
            
            # Group by VIN to find duplicates
            vin_groups = {}
            for i, row in enumerate(data_rows):
                if len(row) > 0:
                    vin = str(row[0]).strip().upper()
                    if vin:
                        if vin not in vin_groups:
                            vin_groups[vin] = []
                        vin_groups[vin].append({"row_index": i + 2, "data": row})  # +2 for header and 1-based indexing
            
            # Find duplicates
            duplicates = {vin: entries for vin, entries in vin_groups.items() if len(entries) > 1}
            total_rows = len(data_rows)
            duplicate_count = sum(len(entries) - 1 for entries in duplicates.values())  # Keep latest, remove others
            
            cleanup_stats = {
                "total_rows": total_rows,
                "unique_vins": len(vin_groups),
                "duplicate_entries": duplicate_count,
                "vins_with_duplicates": len(duplicates),
                "estimated_cells": total_rows * len(headers),
                "cells_to_remove": duplicate_count * len(headers)
            }
            
            logger.info(f"Cleanup analysis: {cleanup_stats}")
            
            if not dry_run and duplicate_count > 0:
                logger.warning("PERFORMING ACTUAL CLEANUP - This will delete duplicate rows!")
                
                # Sort rows to delete in reverse order (highest row numbers first)
                rows_to_delete = []
                for vin, entries in duplicates.items():
                    # Keep the latest entry (last in list), delete others
                    entries_to_delete = sorted(entries[:-1], key=lambda x: x["row_index"], reverse=True)
                    rows_to_delete.extend([entry["row_index"] for entry in entries_to_delete])
                
                rows_to_delete.sort(reverse=True)
                
                # Delete rows (from bottom to top to maintain row numbers)
                deleted_count = 0
                for row_num in rows_to_delete:
                    try:
                        self.fleet_status_worksheet.delete_rows(row_num)
                        deleted_count += 1
                        logger.info(f"Deleted duplicate row {row_num}")
                        
                        # Add delay to avoid rate limiting
                        import time
                        time.sleep(0.1)
                        
                    except Exception as e:
                        logger.error(f"Error deleting row {row_num}: {e}")
                
                cleanup_stats["rows_deleted"] = deleted_count
                logger.info(f"Cleanup complete: deleted {deleted_count} duplicate rows")
            
            return cleanup_stats
            
        except Exception as e:
            logger.error(f"Error during fleet status cleanup: {e}")
            return {"error": str(e)}
    
    def update_fleet_status_sheet_fixed(self, trucks: List[Dict[str, Any]]) -> bool:
        """
        Update fleet_status worksheet with TMS truck data - properly handles existing rows
        without creating duplicates. Updates fleet_status not assets!
        """
        if not self.enable_dashboard_logging or not self.fleet_status_worksheet:
            return False
        
        try:
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Get existing data using safe method to handle header issues
            try:
                all_data = self.fleet_status_worksheet.get_all_values()
                if len(all_data) < 2:
                    # Use correct fleet_status headers
                    headers = [
                        "vin", "driver_name", "last_updated", "latitude", "longitude", "address",
                        "speed_mph", "status", "movement_status", "risk_level", "group_chat_id", "last_contact"
                    ]
                    self.fleet_status_worksheet.update('A1', [headers])
                    existing_records = []
                else:
                    existing_records = all_data[1:]
                    
                # Create VIN to row mapping
                existing_vins = {}
                for i, row in enumerate(existing_records):
                    if len(row) > 0 and row[0]:
                        vin = str(row[0]).strip().upper()
                        existing_vins[vin] = i + 2  # +2 for header and 1-based indexing
                        
            except Exception as e:
                logger.error(f"Error reading existing data: {e}")
                return False
            
            updates_made = 0
            batch_updates = []
            
            for truck in trucks:
                vin = str(truck.get('vin', '')).upper()
                if not vin:
                    continue
                
                # Get driver name from assets worksheet
                try:
                    driver_name = self.get_driver_name_by_vin(vin)
                except Exception:
                    driver_name = None
                
                # Format row data to match fleet_status headers
                row_data = [
                    vin,                                        # vin
                    driver_name or truck.get('name', ''),      # driver_name  
                    current_time,                               # last_updated
                    truck.get('lat', ''),                       # latitude
                    truck.get('lng', ''),                       # longitude
                    truck.get('address', ''),                   # address
                    truck.get('speed', 0),                      # speed_mph
                    truck.get('status', ''),                    # status
                    'MOVING' if truck.get('speed', 0) > 2 else 'STOPPED',  # movement_status
                    'NORMAL',                                   # risk_level
                    '',                                         # group_chat_id (filled when group registers)
                    current_time                                # last_contact
                ]
                
                if vin in existing_vins:
                    # UPDATE existing row - use batch updates for efficiency
                    row_num = existing_vins[vin]
                    batch_updates.append({
                        'range': f'A{row_num}:L{row_num}',  # A to L = 12 columns for fleet_status
                        'values': [row_data]
                    })
                    updates_made += 1
                else:
                    # DO NOT add new rows due to 10M cell limit
                    logger.debug(f"Skipping new VIN {vin} - only updating existing records due to cell limit")
                
                # Limit updates to prevent overload
                if updates_made >= 50:  # Process max 50 trucks per run
                    break
            
            # Execute batch updates
            if batch_updates:
                try:
                    self.fleet_status_worksheet.batch_update(batch_updates)
                    logger.info(f"Batch updated {len(batch_updates)} existing records")
                except Exception as e:
                    logger.error(f"Batch update failed: {e}")
                    # Fall back to individual updates
                    for update in batch_updates:
                        try:
                            range_name = update['range']
                            values = update['values']
                            self.fleet_status_worksheet.update(range_name, values)
                        except Exception as individual_e:
                            logger.error(f"Individual update failed for {range_name}: {individual_e}")
            
            logger.info(f"Updated {updates_made} fleet_status records")
            return True
            
        except Exception as e:
            logger.error(f"Error in fleet_status sheet update: {e}")
            return False
    
    def update_assets_with_current_data(self, limit: int = None) -> Dict[str, Any]:
        """
        Manual command to update assets worksheet with current TMS truck data
        
        Args:
            limit: Maximum number of assets to update in one run
            
        Returns:
            Dictionary with update statistics
        """
        if not self.assets_worksheet:
            return {"error": "Assets worksheet not available"}
        
        try:
            from tms_integration import TMSIntegration
            from robust_sheets_writer import RobustSheetsWriter
            
            # Initialize TMS integration
            tms = TMSIntegration(self.config)
            
            # Load current truck data from TMS
            logger.info("Loading current truck data from TMS...")
            trucks = tms.load_truck_list()
            
            if not trucks:
                return {"error": "No truck data available from TMS"}
            
            logger.info(f"Retrieved {len(trucks)} trucks from TMS")
            
            # Apply limit only if specified (remove artificial cap)
            if limit is not None and limit > 0:
                trucks = trucks[:limit]
                logger.info(f"Limited to {limit} trucks for this run")
            
            # Get existing assets records using safe method
            existing_records = self._get_assets_records_safe()
            
            # Get headers for dynamic column mapping
            try:
                headers = self.assets_worksheet.row_values(1)
                if not headers:
                    return {"error": "Could not read headers from assets sheet"}
            except Exception as e:
                return {"error": f"Failed to read headers: {e}"}
            
            # Use robust writer
            writer = RobustSheetsWriter(self.assets_worksheet, chunk_size=200)
            return writer.write_tms_data_to_assets(trucks, existing_records, headers)
            
        except Exception as e:
            logger.error(f"Error updating assets with current data: {e}", exc_info=True)
            return {"error": f"Update failed: {e}"}
    
    def debug_worksheet_columns(self) -> Dict[str, Any]:
            existing_vins = {}
            for i, record in enumerate(existing_records):
                vin = str(record.get('VIN', '')).strip().upper()
                if vin:
                    existing_vins[vin] = i + 2  # +2 for header and 1-based indexing
            
            updates_made = 0
            new_assets = 0
            errors = []
            batch_updates = []
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Process each truck (limit to prevent overload)
            for truck in trucks[:limit]:
                try:
                    vin = str(truck.get('vin', '')).strip().upper()
                    if not vin:
                        continue
                    
                    # Format truck info for consistent data
                    truck_info = tms.format_truck_info(truck)
                    
                    # Prepare update data
                    update_data = {
                        'lat': truck_info.get('latitude', ''),
                        'lng': truck_info.get('longitude', ''),
                        'current_location': truck_info.get('location', ''),
                        'speed': truck_info.get('speed_display', '0 mph'),
                        'status': truck_info.get('status', 'Unknown'),
                        'last_updated': current_time,
                        'heading': truck_info.get('heading', ''),
                        'source': truck_info.get('source', 'TMS')
                    }
                    
                    if vin in existing_vins:
                        # Update existing asset
                        row_num = existing_vins[vin]
                        
                        # Get current record to preserve existing data
                        existing_record = existing_records[row_num - 2]  # Convert back to 0-based index
                        
                        # Find column indices by checking header row
                        try:
                            headers = self.assets_worksheet.row_values(1)
                            col_mapping = {header.lower().strip(): i + 1 for i, header in enumerate(headers)}
                            
                            # Prepare batch update for specific columns
                            for field, value in update_data.items():
                                if field in col_mapping:
                                    col_letter = chr(64 + col_mapping[field])  # Convert to A, B, C, etc.
                                    batch_updates.append({
                                        'range': f'{col_letter}{row_num}',
                                        'values': [[value]]
                                    })
                            
                            updates_made += 1
                            
                        except Exception as col_error:
                            errors.append(f"Column mapping error for VIN {vin}: {col_error}")
                            continue
                    
                    else:
                        # This is a new truck not in assets worksheet
                        # For now, just log it - you might want to add new assets manually
                        logger.info(f"New truck found (not in assets): {vin} - {truck_info.get('name', 'Unknown')}")
                        new_assets += 1
                
                except Exception as truck_error:
                    errors.append(f"Error processing truck {truck.get('vin', 'Unknown')}: {truck_error}")
                    continue
            
            # Execute batch updates
            updated_count = 0
            if batch_updates:
                try:
                    # Group updates by ranges to optimize API calls
                    logger.info(f"Executing {len(batch_updates)} field updates...")
                    
                    # Process in smaller batches to avoid API limits
                    batch_size = 50
                    for i in range(0, len(batch_updates), batch_size):
                        batch_chunk = batch_updates[i:i + batch_size]
                        
                        try:
                            self.assets_worksheet.batch_update(batch_chunk)
                            updated_count += len(batch_chunk)
                            logger.info(f"Updated batch {i//batch_size + 1}/{(len(batch_updates) + batch_size - 1)//batch_size}")
                            
                            # Small delay between batches
                            import time
                            time.sleep(0.5)
                            
                        except Exception as batch_error:
                            errors.append(f"Batch update error: {batch_error}")
                            # Try individual updates as fallback
                            for update in batch_chunk:
                                try:
                                    self.assets_worksheet.update(update['range'], update['values'])
                                    updated_count += 1
                                except Exception as individual_error:
                                    errors.append(f"Individual update error for {update['range']}: {individual_error}")
                
                except Exception as e:
                    errors.append(f"Batch update setup error: {e}")
            
            # Prepare result summary
            result = {
                "trucks_processed": min(len(trucks), limit),
                "assets_updated": updates_made,
                "field_updates_made": updated_count,
                "new_trucks_found": new_assets,
                "errors": len(errors),
                "timestamp": current_time
            }
            
            if errors and len(errors) <= 10:
                result["error_details"] = errors[:10]
            elif len(errors) > 10:
                result["error_details"] = errors[:10] + [f"... and {len(errors) - 10} more errors"]
            
            logger.info(f"Assets update complete: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Error in manual assets update: {e}")
            return {"error": str(e)}
    
    def debug_worksheet_columns(self) -> Dict[str, Any]:
        """Debug function to check what columns are available in your assets worksheet"""
        try:
            # Get first few rows to see structure
            header_row = self.assets_worksheet.row_values(1)
            sample_rows = self.assets_worksheet.get_all_values()[:3]  # Header + 2 data rows
            
            # Get all records to see field names - use safe method
            records = self._get_assets_records_safe()
            sample_record = records[0] if records else {}
            
            debug_info = {
                "header_row": header_row,
                "sample_rows": sample_rows,
                "available_fields": list(sample_record.keys()) if sample_record else [],
                "sample_record": sample_record,
                "total_records": len(records)
            }
            
            logger.info("=== WORKSHEET DEBUG INFO ===")
            logger.info(f"Header row: {header_row}")
            logger.info(f"Available fields: {debug_info['available_fields']}")
            logger.info(f"Sample record: {sample_record}")
            logger.info("===========================")
            
            return debug_info
            
        except Exception as e:
            logger.error(f"Error debugging worksheet structure: {e}")
            return {"error": str(e)}
    
    def add_new_truck_to_assets(self, vin: str) -> Dict[str, Any]:
        """
        Manually add a specific truck by VIN to the assets worksheet
        
        Args:
            vin: The VIN of the truck to add
            
        Returns:
            Dictionary with operation result
        """
        if not self.assets_worksheet:
            return {"error": "Assets worksheet not available"}
        
        try:
            from tms_integration import TMSIntegration
            
            # Initialize TMS integration
            tms = TMSIntegration(self.config)
            
            # Load current truck data from TMS
            trucks = tms.load_truck_list()
            
            if not trucks:
                return {"error": "No truck data available from TMS"}
            
            # Find the specific truck by VIN
            target_truck = None
            vin_upper = vin.strip().upper()
            
            for truck in trucks:
                if str(truck.get('vin', '')).strip().upper() == vin_upper:
                    target_truck = truck
                    break
            
            if not target_truck:
                return {"error": f"Truck with VIN {vin_upper} not found in TMS data"}
            
            # Check if truck already exists in assets
            existing_records = self._get_assets_records_safe()
            for record in existing_records:
                existing_vin = str(record.get('VIN', '')).strip().upper()
                if existing_vin == vin_upper:
                    return {"error": f"Truck with VIN {vin_upper} already exists in assets worksheet"}
            
            # Format truck info for consistent data
            truck_info = tms.format_truck_info(target_truck)
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Prepare new row data matching the assets worksheet structure
            new_row = [
                target_truck.get('vin', ''),  # VIN
                target_truck.get('unit', ''),  # Unit
                '',  # Driver Name (empty, to be filled manually)
                '',  # Phone (empty, to be filled manually)
                truck_info.get('latitude', ''),  # Lat
                truck_info.get('longitude', ''),  # Lng
                truck_info.get('location', ''),  # Current Location
                truck_info.get('speed_display', '0 mph'),  # Speed
                truck_info.get('status', 'Unknown'),  # Status
                current_time,  # Last Updated
                truck_info.get('heading', ''),  # Heading
                truck_info.get('source', 'TMS'),  # Source
                '',  # Load id (empty, to be filled manually)
                '',  # PU address (empty, to be filled manually)
                '',  # PU appt (empty, to be filled manually)
                '',  # DEL address (empty, to be filled manually)
                '',  # DEL appt (empty, to be filled manually)
                '',  # ETA (empty, calculated later)
                'NORMAL',  # Risk Status
                current_time,  # Sync Time
            ]
            
            # Add the new row to the worksheet
            self.assets_worksheet.append_row(new_row)
            
            logger.info(f"Successfully added new truck VIN {vin_upper} to assets worksheet")
            
            return {
                "success": True,
                "vin": vin_upper,
                "unit": target_truck.get('unit', ''),
                "location": truck_info.get('location', ''),
                "status": truck_info.get('status', 'Unknown'),
                "timestamp": current_time
            }
            
        except Exception as e:
            logger.error(f"Error adding new truck {vin}: {e}")
            return {"error": str(e)}
    
    def list_new_trucks_found(self, limit: int = 20) -> Dict[str, Any]:
        """
        Get a list of trucks that are in TMS but not in assets worksheet
        
        Args:
            limit: Maximum number of new trucks to return
            
        Returns:
            Dictionary with new trucks information
        """
        if not self.assets_worksheet:
            return {"error": "Assets worksheet not available"}
        
        try:
            from tms_integration import TMSIntegration
            
            # Initialize TMS integration
            tms = TMSIntegration(self.config)
            
            # Load current truck data from TMS
            trucks = tms.load_truck_list()
            
            if not trucks:
                return {"error": "No truck data available from TMS"}
            
            # Get existing assets VINs
            existing_records = self._get_assets_records_safe()
            existing_vins = set()
            
            for record in existing_records:
                vin = str(record.get('VIN', '')).strip().upper()
                if vin:
                    existing_vins.add(vin)
            
            # Find new trucks
            new_trucks = []
            for truck in trucks:
                vin = str(truck.get('vin', '')).strip().upper()
                if vin and vin not in existing_vins:
                    truck_info = tms.format_truck_info(truck)
                    new_trucks.append({
                        "vin": vin,
                        "unit": truck.get('unit', ''),
                        "location": truck_info.get('location', ''),
                        "status": truck_info.get('status', 'Unknown'),
                        "name": truck_info.get('name', 'Unknown')
                    })
                
                if len(new_trucks) >= limit:
                    break
            
            logger.info(f"Found {len(new_trucks)} new trucks not in assets worksheet")
            
            return {
                "success": True,
                "new_trucks": new_trucks,
                "total_found": len(new_trucks),
                "existing_assets": len(existing_vins),
                "total_tms_trucks": len(trucks)
            }
            
        except Exception as e:
            logger.error(f"Error listing new trucks: {e}")
            return {"error": str(e)}


def test_google_integration(config: Config) -> bool:
    """Test Google Sheets integration with enhanced driver name testing and QC Panel sync"""
    try:
        print("🧪 Testing Google Sheets integration with QC Panel sync...")
        
        # Create integration instance
        google_integration = GoogleSheetsIntegration(config)
        
        # Test basic connection
        driver_names = google_integration.get_all_driver_names()
        
        if driver_names:
            print(f"✅ Successfully loaded {len(driver_names)} driver names from Google Sheets")
            
            # Show sample driver names
            print(f"📋 Sample driver names: {driver_names[:5]}")
            
            # Test the specific VIN that was showing wrong name
            test_vin = "4V4NC9EH7PN336858"
            driver_name, phone = google_integration.get_driver_contact_info_by_vin(test_vin)
            
            if driver_name:
                print(f"✅ Driver name for VIN {test_vin}: '{driver_name}' (Phone: {phone})")
                
                # Test reverse lookup
                found_vin = google_integration.find_vin_by_driver_name(driver_name)
                if found_vin:
                    print(f"✅ Reverse lookup successful: '{driver_name}' -> VIN: {found_vin}")
                else:
                    print(f"⚠️ Reverse lookup failed for: '{driver_name}'")
            else:
                print(f"❌ No driver name found for VIN: {test_vin}")
            
            # Test QC Panel integration if configured
            if config.QC_PANEL_SPREADSHEET_ID:
                print(f"🔄 Testing QC Panel sync...")
                active_loads = google_integration.get_active_load_map()
                print(f"✅ Found {len(active_loads)} active loads from QC Panel")
                
                # Test sync to assets
                updates = google_integration.sync_active_loads_to_assets()
                print(f"✅ Synced {updates} load updates to assets sheet")
                
                # Test VIN lookup
                if active_loads:
                    sample_vin = list(active_loads.keys())[0]
                    load_status = google_integration.get_active_load_status_for_vin(sample_vin)
                    if load_status:
                        print(f"✅ Load status lookup: VIN {sample_vin} -> {load_status.get('load_id', 'N/A')}")
            else:
                print(f"⚠️ QC Panel not configured, skipping sync tests")
            
            # Test worksheet structure
            debug_info = google_integration.debug_worksheet_columns()
            if 'Driver Name' in debug_info.get('available_fields', []):
                print(f"✅ 'Driver Name' column found in worksheet")
            else:
                print(f"❌ 'Driver Name' column not found. Available fields: {debug_info.get('available_fields', [])}")
            
            print("✅ Google Sheets integration test completed successfully")
            return True
        else:
            print("❌ No driver names loaded from Google Sheets")
            return False
        
    except Exception as e:
        print(f"❌ Google Sheets integration test failed: {str(e)}")
        return False
    
    # =====================================================
    # COMPREHENSIVE SHEETS MODEL INTERFACE METHODS
    # =====================================================
    
    async def upsert_assets_from_tms(self, tms_assets) -> int:
        """Interface to sheets model for assets upsert"""
        if self.sheets_model:
            return await self.sheets_model.upsert_assets_from_tms(tms_assets)
        else:
            logger.error("Sheets model not initialized")
            return 0
    
    async def register_or_update_group(self, group_id: int, title: str, vin: str, 
                                     owner_user_id: Optional[int] = None) -> None:
        """Interface to sheets model for group registration"""
        if self.sheets_model:
            await self.sheets_model.register_or_update_group(group_id, title, vin, owner_user_id)
        else:
            logger.error("Sheets model not initialized")
    
    async def record_group_rename(self, group_id: int, new_title: str) -> None:
        """Interface to sheets model for group rename tracking"""
        if self.sheets_model:
            await self.sheets_model.record_group_rename(group_id, new_title)
        else:
            logger.error("Sheets model not initialized")
    
    def batch_update_eld_tracker(self, points) -> int:
        """Interface to sheets model for ELD_tracker F:K batch updates"""
        if self.sheets_model:
            return self.sheets_model.batch_update_eld_tracker(points)
        else:
            logger.error("Sheets model not initialized")
            return 0
    
    def upsert_fleet_status(self, rows) -> int:
        """Interface to sheets model for fleet_status upserts"""
        if self.sheets_model:
            return self.sheets_model.upsert_fleet_status(rows)
        else:
            logger.error("Sheets model not initialized")
            return 0
    
    def append_location_logs(self, events) -> int:
        """Interface to sheets model for location_logs appends"""
        if self.sheets_model:
            return self.sheets_model.append_location_logs(events)
        else:
            logger.error("Sheets model not initialized")
            return 0
    
    def append_ack_audit(self, entry: dict) -> None:
        """Interface to sheets model for ACK audit logging"""
        if self.sheets_model:
            self.sheets_model.append_ack_audit(entry)
        else:
            logger.error("Sheets model not initialized")
    
    def append_dashboard_hourly(self, summary: dict) -> None:
        """Interface to sheets model for dashboard KPI logging"""
        if self.sheets_model:
            self.sheets_model.append_dashboard_hourly(summary)
        else:
            logger.error("Sheets model not initialized")
    
    def prune_location_logs_older_than(self, days: int) -> int:
        """Interface to sheets model for retention management"""
        if self.sheets_model:
            return self.sheets_model.prune_location_logs_older_than(days)
        else:
            logger.error("Sheets model not initialized")
            return 0
    
    def log_severe_error(self, component: str, severity: str, summary: str, 
                        detail: str = "", context: str = "") -> None:
        """Interface to sheets model for severe error logging"""
        if self.sheets_model:
            self.sheets_model.log_severe_error(component, severity, summary, detail, context)
        else:
            logger.error("Sheets model not initialized")
    
    def get_sheets_metrics(self) -> Dict[str, Any]:
        """Get comprehensive sheets model metrics"""
        if self.sheets_model:
            return self.sheets_model.get_metrics()
        else:
            logger.error("Sheets model not initialized")
            return {}